

#include <chrono>
#include <cusparse.h>
#include <thrust/device_vector.h>
#include <thrust/sequence.h>
#include <thrust/adjacent_difference.h>
#include <thrust/iterator/zip_iterator.h>
#include <thrust/iterator/constant_iterator.h>
#include <nccl.h>
#include "MPIWrapper.hpp"
#define TGET(x,i) thrust::get<i>(x)
template <typename Func,typename...Arg>
__host__ __device__
auto apply(Func func, Arg... args) {
  return func(args...);
}

// ----------------- 
// |       |       |
// |   3   |   2   |
// |       |       |
// |---------------|
// |       |       |
// |   0   |   1   |
// |       |       |
// -----------------


template <int i>
struct index_of_each_node;

template <int i>
struct weight_to_each_node;


template<>
struct index_of_each_node<0> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+idx[1]*ng[0]+idx[2]*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else if constexpr (idx.size()==2)
      return std::min(static_cast<idx_type>(idx[0]+idx[1]*ng[0]), ng[0]*ng[1]);
    else if constexpr (idx.size()==1)
      return std::min(static_cast<idx_type>(idx[0]),ng[0]);
    else {}
  }
};

template<>
struct weight_to_each_node<0> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return (1.0-wei[0])*(1.0-wei[1])*(1.0-wei[2]);
    else if constexpr (wei.size()==2)
      return (1.0-wei[0])*(1.0-wei[1]);
    else if constexpr (wei.size()==1)
      return (1.0-wei[0]);
    else {}
  }

};


template<>
struct index_of_each_node<1> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+1+idx[1]*ng[0]+idx[2]*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else if constexpr (idx.size()==2)
      return std::min(static_cast<idx_type>(idx[0]+1+idx[1]*ng[0]), ng[0]*ng[1]);
    else if constexpr (idx.size()==1)
      return std::min(static_cast<idx_type>(idx[0]+1),ng[0]);
    else {}
  }
};

template<>
struct weight_to_each_node<1> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return wei[0]*(1.0-wei[1])*(1.0-wei[2]);
    else if constexpr (wei.size()==2)
      return wei[0]*(1.0-wei[1]);
    else if constexpr (wei.size()==1)
      return wei[0];
    else {}
  }

};

template<>
struct index_of_each_node<2> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+1+(idx[1]+1)*ng[0]+idx[2]*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else if constexpr (idx.size()==2)
      return std::min(static_cast<idx_type>(idx[0]+1+(idx[1]+1)*ng[0]), ng[0]*ng[1]);
    else {}
  }
};

template<>
struct weight_to_each_node<2> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return (wei[0])*(wei[1])*(1.0-wei[2]);
    else if constexpr (wei.size()==2)
      return (wei[0])*(wei[1]);
    else {}
  }
};

template<>
struct index_of_each_node<3> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+(idx[1]+1)*ng[0]+idx[2]*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else if constexpr (idx.size()==2)
      return std::min(static_cast<idx_type>(idx[0]+(idx[1]+1)*ng[0]), ng[0]*ng[1]);
    else {}
  }
};

template<>
struct weight_to_each_node<3> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return (1.0-wei[0])*(wei[1])*(1.0-wei[2]);
    else if constexpr (wei.size()==2)
      return (1.0-wei[0])*(wei[1]);
    else {}
  }
};


template<>
struct index_of_each_node<4> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+idx[1]*ng[0]+(idx[2]+1)*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else {}
  }
};

template<>
struct weight_to_each_node<4> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return (1.0-wei[0])*(1.0-wei[1])*wei[2];
    else {}
  }

};


template<>
struct index_of_each_node<5> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+1+idx[1]*ng[0]+(idx[2]+1)*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else {}
  }
};

template<>
struct weight_to_each_node<5> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return wei[0]*(1.0-wei[1])*wei[2];
    else if constexpr (wei.size()==2)
      return wei[0]*(1.0-wei[1]);
    else {}
  }

};


template<>
struct index_of_each_node<6> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+1+(idx[1]+1)*ng[0]+(idx[2]+1)*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else {}
  }
};

template<>
struct weight_to_each_node<6> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return (wei[0])*(wei[1])*wei[2];
    else {}
  }
};

template<>
struct index_of_each_node<7> {

  template <typename Array1,typename Array2>
  __host__ __device__
  auto operator()(Array1 idx,Array2 ng) {
    using idx_type = decltype(ng)::value_type;
    if constexpr (idx.size()==3)
      return std::min(static_cast<idx_type>(idx[0]+(idx[1]+1)*ng[0]+(idx[2]+1)*ng[1]*ng[0]),
                 ng[0]*ng[1]*ng[2]);
    else {}
  }
};

template<>
struct weight_to_each_node<7> {
  
  template <typename Array>
  __host__ __device__
  auto operator()(Array wei) {
    if constexpr (wei.size()==3)
      return (1.0-wei[0])*(wei[1])*wei[2];
    else {}
  }
};

template <typename val_type, typename idx_type, int xdim>
struct tupleTraits;

template <typename val_type, typename idx_type>
struct tupleTraits<val_type,idx_type,1> {

  using ValItor  = thrust::device_vector<val_type>::iterator;
  using IdxItor  = thrust::device_vector<idx_type>::iterator;

  using ParticleZipItor = thrust::zip_iterator<thrust::tuple<ValItor>>;
  using IndexZipItor    = thrust::zip_iterator<thrust::tuple<IdxItor,IdxItor>>;
  using WeightZipItor   = thrust::zip_iterator<thrust::tuple<ValItor,ValItor>>;
  using IntpZipItor     = thrust::zip_iterator<
                            thrust::tuple<ParticleZipItor,IndexZipItor,WeightZipItor>>;

  using ParticleTupleRef = thrust::detail::
                             tuple_of_iterator_references<val_type&>;
  using IndexTupleRef    = thrust::detail::
                             tuple_of_iterator_references<
                               idx_type&,idx_type&>;
  using WeightTupleRef   = thrust::detail::
                             tuple_of_iterator_references<
                               val_type&,val_type&>;
  using IntpTupleRef     = thrust::detail::
                             tuple_of_iterator_references
                               <ParticleTupleRef,IndexTupleRef,WeightTupleRef>;
};


template <typename val_type, typename idx_type>
struct tupleTraits<val_type,idx_type,2> {

  using ValItor  = thrust::device_vector<val_type>::iterator;
  using IdxItor  = thrust::device_vector<idx_type>::iterator;

  using ParticleZipItor = thrust::zip_iterator<thrust::tuple<ValItor,ValItor>>;
  using IndexZipItor    = thrust::zip_iterator<thrust::tuple<IdxItor,IdxItor,
                                                             IdxItor,IdxItor>>;
  using WeightZipItor   = thrust::zip_iterator<thrust::tuple<ValItor,ValItor,
                                                             ValItor,ValItor>>;
  using IntpZipItor     = thrust::zip_iterator<
                          thrust::tuple<ParticleZipItor,IndexZipItor,WeightZipItor>>;

  using ParticleTupleRef = thrust::detail::
                      tuple_of_iterator_references<
                      val_type&,val_type&>;
  using WeightTupleRef = thrust::detail::
                       tuple_of_iterator_references<
                       val_type&,val_type&,val_type&,val_type&>;


  using IndexTupleRef = thrust::detail::
                       tuple_of_iterator_references<
                       idx_type&,idx_type&,idx_type&,idx_type&>;
 
  using IntpTupleRef = thrust::detail::
                            tuple_of_iterator_references
                            <ParticleTupleRef,IndexTupleRef,WeightTupleRef>;
};

template <typename val_type, typename idx_type>
struct tupleTraits<val_type,idx_type,3> {

  using ValItor  = thrust::device_vector<val_type>::iterator;
  using IdxItor  = thrust::device_vector<idx_type>::iterator;

  using ParticleZipItor = thrust::zip_iterator<thrust::tuple<ValItor,ValItor,ValItor>>;
  using IndexZipItor    = thrust::zip_iterator<thrust::tuple<IdxItor,IdxItor,
                                                             IdxItor,IdxItor, 
                                                             IdxItor,IdxItor,
                                                             IdxItor,IdxItor>>;
  using WeightZipItor   = thrust::zip_iterator<thrust::tuple<ValItor,ValItor,
                                                             ValItor,ValItor,
                                                             ValItor,ValItor,
                                                             ValItor,ValItor>>;
  using IntpZipItor     = thrust::zip_iterator<
                          thrust::tuple<ParticleZipItor,IndexZipItor,WeightZipItor>>;

  using ParticleTupleRef = thrust::detail::
                             tuple_of_iterator_references<
                               val_type&,val_type&,val_type&>;
  using IndexTupleRef = thrust::detail::
                          tuple_of_iterator_references<
                            idx_type&,idx_type&,idx_type&,idx_type&,
                              idx_type&,idx_type&,idx_type&,idx_type&>;
  using WeightTupleRef = thrust::detail::
                           tuple_of_iterator_references<
                             val_type&,val_type&,val_type&,val_type&,
                               val_type&,val_type&,val_type&,val_type&>;
  using IntpTupleRef = thrust::detail::
                        tuple_of_iterator_references
                          <ParticleTupleRef,IndexTupleRef,WeightTupleRef>;
};


template <typename idx_type>
struct cusparseIndexTypeTraits {
  static constexpr cusparseIndexType_t type() {
    if constexpr (sizeof(idx_type)==4)
      return CUSPARSE_INDEX_32I;
    else if  (sizeof(idx_type)==8)
      return CUSPARSE_INDEX_64I;
  }
};


template <typename val_type>
struct cudaDataTypeTraits {
  static constexpr cudaDataType_t type() {
    if constexpr (sizeof(val_type)==4)
      return CUDA_R_32F;
    else if  (sizeof(val_type)==8)
      return CUDA_R_64F;
  }
};

template <typename idx_type>
constexpr idx_type static_pow(idx_type val,int n) {
  return  (n==0) ? 1 : (val*static_pow(val,n-1));
}


template <typename idx_type, typename val_type, idx_type xdim>
struct calVal {

  using ParticleTupleRef = typename tupleTraits<val_type,idx_type,xdim>::ParticleTupleRef;
  using IntpTupleRef     = typename tupleTraits<val_type,idx_type,xdim>::IntpTupleRef;
  using WeightTupleRef   = typename tupleTraits<val_type,idx_type,xdim>::WeightTupleRef;

  std::array<val_type,xdim> x0,dx; 
  std::array<idx_type,xdim> ng;

  __host__ __device__
  calVal(const std::array<val_type,xdim>& x0,
         const std::array<val_type,xdim>& dx,
         const std::array<idx_type,xdim>& ng) 
  : x0(x0),dx(dx),ng(ng) {}


  template <idx_type...idx>
  __host__ __device__
  auto calIndex(std::index_sequence<idx...>, 
                std::array<val_type,xdim> index,
                std::array<idx_type,xdim> ng) {
    // 计算每个节点(1d->2/2d->4/3d->8)在一维内存中的索引(即插值矩阵的非0行标)
    return thrust::make_tuple(::apply(index_of_each_node<idx>(),index,ng)...);
  }

  template <idx_type...idx>
  __host__ __device__
  auto calWeight(std::index_sequence<idx...>, 
                 std::array<val_type,xdim> wei) {
    return thrust::make_tuple(::apply(weight_to_each_node<idx>(),wei)...);
  }

  __host__ __device__
  void operator()(IntpTupleRef t)  {

    std::array<val_type,xdim> idx,wei;
      
    // 注意ghost网格带来的偏移
    wei[0] = std::modf((TGET(TGET(t,0/*particle*/),0)-x0[0]+dx[0])/dx[0],idx.data());
    if constexpr (xdim>1)
      wei[1] = std::modf((TGET(TGET(t,0),1)-x0[1])/dx[1],idx.data()+1);
    if constexpr (xdim>2) 
      wei[2] = std::modf((TGET(TGET(t,0),2)-x0[2])/dx[2],idx.data()+2);
      
    constexpr idx_type num_nodes = static_pow(2,xdim);
    TGET(t,1/*index*/)  = calIndex (std::make_index_sequence<num_nodes>{},idx,ng);
    TGET(t,2/*weight*/) = calWeight(std::make_index_sequence<num_nodes>{},wei);

  }

};




template<typename PIC>
struct Interp {

  using Container  = typename PIC::ParticleContainer;
  using idx_type   = PIC::index_type;
  using val_type   = PIC::value_type;
  using Species    = PIC::Species;
  using Cell       = PIC::Cell;
  static constexpr int n_species = static_cast<idx_type>(PIC::n_species), 
                           dim_x = static_cast<idx_type>(PIC::dim_x), 
                           dim_v = static_cast<idx_type>(PIC::dim_v);

  cudaDataType_t cudaDataType 
    = cudaDataTypeTraits<val_type>::type();
  cusparseIndexType_t cusparseIndexType 
    = cusparseIndexTypeTraits<idx_type>::type(); 

  cusparseSpMatDescr_t matA = nullptr;
  cusparseDnVecDescr_t X = nullptr, Y = nullptr;
  cusparseHandle_t     handle     = nullptr;
  void*                dBuffer    = nullptr;
  size_t               bufferSize = 0;
  const val_type       alpha = 1., beta = 0.;

  static constexpr idx_type dot = static_pow(2,dim_x);

  std::array<thrust::device_vector<idx_type>,n_species> A_cols, A_ccsr;
  std::array<thrust::device_vector<val_type>,n_species> A_vals;

  using ParticleZipItor = tupleTraits<val_type,idx_type,dim_x>::ParticleZipItor;
  using IndexZipItor    = tupleTraits<val_type,idx_type,dim_x>::IndexZipItor;
  using WeightZipItor   = tupleTraits<val_type,idx_type,dim_x>::WeightZipItor;
  using IntpZipItor     = thrust::zip_iterator<
                          thrust::tuple<ParticleZipItor,IndexZipItor,WeightZipItor>>;

  ParticleZipItor z_itor_par;
  IndexZipItor    z_itor_col;
  WeightZipItor   z_itor_val;
  IntpZipItor     z_itor_pcv;

  idx_type n_rows[n_species], n_cols, n_nz[n_species];    
  
  Interp(Cell& cell) : n_cols(cell.ng1) {
    n_cols = cell.ng1;
  }

  void calWeight(Species& sp, Cell& cell) {

    for (int s=0; s<n_species; ++s) {
      n_rows[s] = sp[s].np;
      n_nz[s]   = n_rows[s]*dot; // #none-zero elements

      // prepare to assemble the sparse matrix (i,j,val)
      A_cols[s].resize(n_nz[s]);  // column index
      A_vals[s].resize(n_nz[s]);  // element value
      A_ccsr[s].resize(n_rows[s]+1);
      thrust::sequence(A_ccsr[s].begin(),A_ccsr[s].end(),static_cast<idx_type>(0),dot);

      // 23dimension tomultiply
      z_itor_par = thrust::make_zip_iterator(sp[s].x[0].begin());
      z_itor_col = thrust::make_zip_iterator(A_cols[s].begin()+0*n_rows[s],
                                             A_cols[s].begin()+1*n_rows[s]);
      z_itor_val = thrust::make_zip_iterator(A_vals[s].begin()+0*n_rows[s],
                                             A_vals[s].begin()+1*n_rows[s]);
      z_itor_pcv = thrust::make_zip_iterator(z_itor_par,z_itor_col,z_itor_val);

      // from particle position to calculate the index: A_cols, 
      // and the cooresponding weight: A_vals
      thrust::for_each(z_itor_pcv,z_itor_pcv+n_rows[s],
                       calVal(cell.a,cell.h,cell.ng_al));
      
    }// for species
  }
  void particle2cell(Species& sp, Cell& cell) {

    for (int s=0; s<n_species; ++s) {

      val_type qw = sp[s].q *sp[s].w;
      thrust::device_vector<val_type> ones(n_rows[s]);
      thrust::fill(ones.begin(),ones.end(),qw);

      cusparseCreate(&handle);
      cusparseCreateCsr(&matA, n_rows[s], n_cols, n_nz[s], // cols and rows inversed (transpose)
                        thrust::raw_pointer_cast(A_ccsr[s].data()),
                        thrust::raw_pointer_cast(A_cols[s].data()),
                        thrust::raw_pointer_cast(A_vals[s].data()),
                        cusparseIndexType,
                        cusparseIndexType,
                        CUSPARSE_INDEX_BASE_ZERO,
                        cudaDataType);
      
      cusparseCreateDnVec(&X, n_rows[s], // particle 
                          thrust::raw_pointer_cast(ones.data()), cudaDataType);
      cusparseCreateDnVec(&Y, n_cols,    // cell
                          thrust::raw_pointer_cast(cell.edens[s].data()), cudaDataType);
      cusparseSpMV_bufferSize(handle,CUSPARSE_OPERATION_TRANSPOSE,
                              &alpha,matA,X,
                              &beta,      Y, cudaDataType,
                              CUSPARSE_SPMV_CSR_ALG2,&bufferSize);
      cudaMalloc(&dBuffer,bufferSize); 
      cusparseSpMV(handle,CUSPARSE_OPERATION_TRANSPOSE,
                   &alpha,matA,X,
                   &beta,      Y,cudaDataType,
                   CUSPARSE_SPMV_CSR_ALG2,dBuffer);
      for (int d=0; d<dim_v; d++) {
        cusparseCreate(&handle);
        cusparseCreateCsr(&matA, n_rows[s],n_cols, n_nz[s],
                        thrust::raw_pointer_cast(A_ccsr[s].data()),
                        thrust::raw_pointer_cast(A_cols[s].data()),
                        thrust::raw_pointer_cast(A_vals[s].data()),
                        cusparseIndexType,
                        cusparseIndexType,
                        CUSPARSE_INDEX_BASE_ZERO,
                        cudaDataType);
        cusparseCreateDnVec(&X, n_rows[s], 
                            thrust::raw_pointer_cast(sp[s].v[d].data()), cudaDataType);
        cusparseCreateDnVec(&Y, n_cols, 
                            thrust::raw_pointer_cast(cell.jsfield[s][d].data()), cudaDataType);
        cusparseSpMV_bufferSize(handle,CUSPARSE_OPERATION_TRANSPOSE,
                                &alpha,matA,X,
                                &beta,      Y, cudaDataType,
                                CUSPARSE_SPMV_CSR_ALG2,&bufferSize);
        cudaMalloc(&dBuffer,bufferSize); 
        cusparseSpMV(handle,CUSPARSE_OPERATION_TRANSPOSE,
                     &alpha,matA,X,
                     &beta,      Y,cudaDataType,
                     CUSPARSE_SPMV_CSR_ALG2,dBuffer);

        // 乘上电荷以及粒子权重
        thrust::for_each(cell.jsfield[s][d].begin(),cell.jsfield[s][d].end(),
                         [qw]__host__ __device__(val_type& val) { val *= qw; });
      }
    } // for species

  }

  void cell2particle(Species& sp, Cell& cell) {
/*
    thrust::device_vector<val_type> buf(cell.ng1+1);
    for (int s=0; s<n_species; ++s) {

      // Yee cell Bx
      thrust::adjacent_difference(cell.bfield[0].begin(),cell.bfield[0].end(),
                                  buf.begin(),thrust::plus<val_type>());
      thrust::for_each(buf.begin(),buf.end(),
                       []__host__ __device__ (val_type& x){ x *=.5; });
      buf[1] = buf[cell.ng1-2];
      Matc2p[s].multiply(thrust::raw_pointer_cast(buf.data()+1),
          thrust::raw_pointer_cast(sp[s].B[0].data()));
      // Yee cell Ey
      thrust::adjacent_difference(cell.efield[1].begin(),cell.efield[1].end(),
                                  buf.begin(),thrust::plus<val_type>());
      thrust::for_each(buf.begin(),buf.end(),
                       []__host__ __device__ (val_type& x){ x *=.5; });
      buf[1] = buf[cell.ng1-2];
      Matc2p[s].multiply(thrust::raw_pointer_cast(buf.data()+1),
          thrust::raw_pointer_cast(sp[s].E[1].data()));
      // Yee cell Ez
      thrust::adjacent_difference(cell.efield[2].begin(),cell.efield[2].end(),
                                  buf.begin(),thrust::plus<val_type>());
      thrust::for_each(buf.begin(),buf.end(),
                       []__host__ __device__ (val_type& x){ x *=.5; });
      buf[1] = buf[cell.ng1-2];
      Matc2p[s].multiply(thrust::raw_pointer_cast(buf.data()+1),
          thrust::raw_pointer_cast(sp[s].E[2].data()));

      Matc2p[s].multiply(thrust::raw_pointer_cast(cell.efield[0].data()),
          thrust::raw_pointer_cast(sp[s].E[0].data()));
      Matc2p[s].multiply(thrust::raw_pointer_cast(cell.bfield[1].data()),
          thrust::raw_pointer_cast(sp[s].B[1].data()));
      Matc2p[s].multiply(thrust::raw_pointer_cast(cell.bfield[2].data()),
          thrust::raw_pointer_cast(sp[s].B[2].data()));
    } // for species
 */      
  }   
};
